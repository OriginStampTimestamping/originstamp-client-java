/*
 * OriginStamp Documentation
 * <br/>The following documentation describes the API v3 for OriginStamp. With this documentation you are able to try out the different requests and see the responses. For the authorization, add your API key to the Authorization header of your request.<br/><h2>Invoice</h2><p>The invoice is based on your individual usage. The following table illustrates the credits,that are billed in credits.</p><table><tr><th>Request Type</th><th>Condition</th><th>Credits</th><tr><th>Submission</th><th>create timestamp</th><th>1 Credit</th><tr><th>Submission</th><th>timestamp already exists</th><th>0.3 Credits</th><tr><th>Status</th><th>no timestamp information available</th><th>0.1 Credit</th><tr><th>Status</th><th>timestamp information</th><th>0.3 Credits</th><tr><th>Proof</th><th>no proof available</th><th>0.1 Credits</th><tr><th>Proof</th><th>merkle tree as proof</th><th>3 Credits</th><tr><th>Proof</th><th>seed as proof</th><th>3 Credits</th><tr><th>Proof</th><th>PDF Certificate</th><th>5 Credits</th><tr><th>Notification</th><th>webhook notification</th><th>1.5 Credits</th><tr><th>Notification</th><th>mail notification</th><th>5 Credits</th></table>
 *
 * OpenAPI spec version: 3.0
 * Contact: mail@originstamp.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.swagger.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;

/**
 * DTO for the timestamp data.
 */
@ApiModel(description = "DTO for the timestamp data.")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2018-10-25T14:37:55.412Z")
public class TimestampData {
  @SerializedName("currency_id")
  private Integer currencyId = null;

  @SerializedName("private_key")
  private String privateKey = null;

  @SerializedName("submit_status")
  private Long submitStatus = null;

  @SerializedName("timestamp")
  private Long timestamp = null;

  @SerializedName("transaction")
  private String transaction = null;

  public TimestampData currencyId(Integer currencyId) {
    this.currencyId = currencyId;
    return this;
  }

   /**
   * 0: Bitcoin  1: Ethereum  more to be added
   * @return currencyId
  **/
  @ApiModelProperty(value = "0: Bitcoin  1: Ethereum  more to be added")
  public Integer getCurrencyId() {
    return currencyId;
  }

  public void setCurrencyId(Integer currencyId) {
    this.currencyId = currencyId;
  }

  public TimestampData privateKey(String privateKey) {
    this.privateKey = privateKey;
    return this;
  }

   /**
   * The private key represents the top hash in the Merkle Tree (see &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/Merkle_tree\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Wikipedia&lt;/a&gt;) or the hash of all hashes in the transaction.
   * @return privateKey
  **/
  @ApiModelProperty(value = "The private key represents the top hash in the Merkle Tree (see <a href=\"https://en.wikipedia.org/wiki/Merkle_tree\" target=\"_blank\">Wikipedia</a>) or the hash of all hashes in the transaction.")
  public String getPrivateKey() {
    return privateKey;
  }

  public void setPrivateKey(String privateKey) {
    this.privateKey = privateKey;
  }

  public TimestampData submitStatus(Long submitStatus) {
    this.submitStatus = submitStatus;
    return this;
  }

   /**
   * The submit status of the hash:   0: the hash was not broadcasted yet  1: the hash was included into a transaction and broadcasted to the network, but not included into a block  2: the transaction was included into the latest block  3: the timestamp for your hash was successfully created.
   * @return submitStatus
  **/
  @ApiModelProperty(value = "The submit status of the hash:   0: the hash was not broadcasted yet  1: the hash was included into a transaction and broadcasted to the network, but not included into a block  2: the transaction was included into the latest block  3: the timestamp for your hash was successfully created.")
  public Long getSubmitStatus() {
    return submitStatus;
  }

  public void setSubmitStatus(Long submitStatus) {
    this.submitStatus = submitStatus;
  }

  public TimestampData timestamp(Long timestamp) {
    this.timestamp = timestamp;
    return this;
  }

   /**
   * Unix timestamp in milliseconds. Timezone: UTC. This is a true timestamp.
   * @return timestamp
  **/
  @ApiModelProperty(value = "Unix timestamp in milliseconds. Timezone: UTC. This is a true timestamp.")
  public Long getTimestamp() {
    return timestamp;
  }

  public void setTimestamp(Long timestamp) {
    this.timestamp = timestamp;
  }

  public TimestampData transaction(String transaction) {
    this.transaction = transaction;
    return this;
  }

   /**
   * If available: the transaction hash.
   * @return transaction
  **/
  @ApiModelProperty(value = "If available: the transaction hash.")
  public String getTransaction() {
    return transaction;
  }

  public void setTransaction(String transaction) {
    this.transaction = transaction;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TimestampData timestampData = (TimestampData) o;
    return Objects.equals(this.currencyId, timestampData.currencyId) &&
        Objects.equals(this.privateKey, timestampData.privateKey) &&
        Objects.equals(this.submitStatus, timestampData.submitStatus) &&
        Objects.equals(this.timestamp, timestampData.timestamp) &&
        Objects.equals(this.transaction, timestampData.transaction);
  }

  @Override
  public int hashCode() {
    return Objects.hash(currencyId, privateKey, submitStatus, timestamp, transaction);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TimestampData {\n");
    
    sb.append("    currencyId: ").append(toIndentedString(currencyId)).append("\n");
    sb.append("    privateKey: ").append(toIndentedString(privateKey)).append("\n");
    sb.append("    submitStatus: ").append(toIndentedString(submitStatus)).append("\n");
    sb.append("    timestamp: ").append(toIndentedString(timestamp)).append("\n");
    sb.append("    transaction: ").append(toIndentedString(transaction)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

